#!/bin/bash

# From https://github.com/networkimprov/omap3-usb-boot-install
#
# Install script to cold flash over USB using an image made of
# subimages for MLO, u-boot, script, dtb, zimage and initrd.
#
# If a sub-image is not specified, an empty one is created.
#
# This tool uses modified omap34usbboot.tar.gz that's available at:
# https://groups.google.com/forum/#!topic/pandaboard/9z5ebHEnuqs
#
# The MLO is generated by u-boot when it's compiled with:
# $ CONFIG_SPL=1 CROSS_COMPILE=arm-linux-gnueabi- make
#
# The u-boot install script is created from install.src with:
# $ mkimage -T script -C none -n "Install script" -d install.src u-boot.script
#
# The mkimage tool comes with u-boot or can be installed with
# u-boot-tools package.

SZ_512K=524288
SZ_1M=1048576
SZ_2M=2097152
SZ_8M=8388608
SZ_20M=20971520

update=0
loop=0
tests=0
install=0
dieid=""
rootfs_file=""

main() {
  check_options $@

  #cd $(dirname $0) # ? in case run from outside home dir

  if [ "$update" == "1" ]; then
    echo "Update cold flash images..."
    update_images
  fi

  while [ "$install" == "1" ]; do
    if [ "$rootfs_file" == "erase" ]; then
      echo "Wiping u-boot in NAND..."
      cold_flash images/erase-image
    elif [ "$rootfs_file" == "kernel" ]; then
      echo "Booting kernel without flashing..."
      cold_flash images/kernel-image
    else
      echo "Cold flashing over USB..."
      cold_flash images/install-image

      # Valid dieid length must be 32
      if [ ${#dieid} != "32" ]; then
        error_exit "ERROR: Bad dieid $dieid ${#dieid}"
      fi

      disk="/dev/disk/by-id/usb-Linux_File-Stor_Gadget_"$dieid"-0:0"
      uart="/dev/serial/by-id/usb-Network_Improv_Multi_Gadget_"$dieid"-if02" # usb-Anvl_Multi_Gadget

      wait_for_emmc $disk

      echo "Debug UART at $uart"

      if [ "$tests" == "1" ]; then
        if [ ! -c $uart ]; then
          error_exit "ERROR: Could not find UART $uart"
        fi
        echo "Running test scripts.."
        if ! serial_run_shell_script $uart scripts/led_blink_yellow.sh 0; then
          if [ "$loop" == "1" ]; then
            echo "Set aside this device for repair, and connect the next device"
            continue
          else
            break
          fi
        fi
      fi

      if [ "$rootfs_file" == "" ]; then
        echo "WARNING: No rootfs specified, assuming manual install"
      else
        if [ ! -f $rootfs_file ]; then
          error_exit "ERROR: Could not find file (or absolute path) for rootfs $rootfs_file"
        fi

        install_on_emmc $dieid $disk $rootfs_file

        serial_run_shell_script $uart scripts/led_blink_green.sh 0
      fi
    fi

    if [ "$loop" == "1" ]; then
      echo "Done, please connect the next device"
    else
      echo "Done, please power cycle the device"
      break
    fi
  done

  exit 0
}

options_exit() {
  echo "usage: $0 [-u | --update] [-i | --install[=][rootfs.tar.gz | erase | kernel]] [-t | --tests] [-l | --loop]"
  exit 1
}

error_exit() {
  echo $1
  exit 1
}

check_options() {
  if [ $# -lt 1 ]; then
    options_exit
  fi

  if ! options=$(getopt -o ui::lt -l update,install::,loop,tests -- "$@"); then
    options_exit
  fi

  eval set -- "$options"

  while [ $# -gt 0 ]; do
    case $1 in
    -u|--update)
      update=1
    ;;
    -i|--install)
      install=1
      rootfs_file=$2
      shift
    ;;
    -l|--loop)
      loop=1
    ;;
    -t|--tests)
      tests=1
    ;;
    (--)
      shift
      break
    ;;
    (-*)
      error_exit "Unknown option $1"
    ;;
    *)
      options_exit
    ;;
    esac
    shift
  done
}

cold_flash() {
  image=$1

  # Check for a locally compiled omap34usbboot binary first
  if [ -f src/omap34usbboot/out/usbboot ]; then
    prefix=src/omap34usbboot/out
  else
    arch=$(uname -m)
    case "$arch" in
    i?86)
      prefix=arch/i386
    ;;
    x86_64)
      prefix=arch/x86_64
    ;;
    *)
      error_exit "Unsupported architecture, please build src/omap34usbboot manually"
    ;;
    esac
  fi

  while read -r output; do
    echo $output
    if echo $output | grep "No such file or directory" > /dev/null; then
      exit 2
    fi 
    if echo $output | grep "command not found" > /dev/null; then
      exit 3
    fi 
    if echo $output | grep "unexpected 2ndstage response" > /dev/null; then
      exit 4
    fi 
    dieid=$(echo $output | awk '{ split($0,a,"dieid: "); print substr(a[2], 1, 32) }')
  done < <(sudo $prefix/usbboot $prefix/omap3_aboot $image 2>&1)

  if [ "$dieid" = "" ]; then
    error_exit "ERROR: failed to get dieid"
  fi

  return 0
}

pad_image() {
  file="$1"
  pad_size="$2"

  if [ ! -f $file ]; then
    echo "Creating empty $file"
    touch $file
  fi

  size=$(du -b "$file" | cut -f 1)
  if [ $size -gt $pad_size ]; then
    error_exit "ERROR: $file too big"
  fi

  if [ $size -lt $pad_size ]; then
    echo "Padding $file from $size to $pad_size"
    if ! truncate -s $pad_size $file; then
      error_exit "ERROR: truncate failed for $file"
    fi
  fi
}

update_images() {

  if ! mkimage -A arm -T script -C none -n "Install script" -d src/scripts/boot.script images/boot.scr; then
    error_exit "ERRROR: could not mkimage install script"
  fi

  if ! mkimage -A arm -T script -C none -n "Erase script" -d src/scripts/erase.script images/erase.scr; then
    error_exit "ERRROR: could not mkimage erase script"
  fi

  if ! mkimage -A arm -T script -C none -n "Kernel boot script" -d src/scripts/kernel.script images/kernel.scr; then
    error_exit "ERRROR: could not mkimage kernel boot script"
  fi

  pad_image images/u-boot.bin $SZ_512K    # at 0x80008000
  pad_image images/MLO $SZ_512K           # at 0x80088000
  pad_image images/u-boot.img $SZ_512K    # at 0x80108000

  # One of these depending of the command line options
  pad_image images/boot.scr $SZ_512K      # at 0x80188000
  pad_image images/erase.scr $SZ_512K	  # at 0x80188000
  pad_image images/kernel.scr $SZ_512K    # at 0x80188000

  pad_image images/dtb $SZ_2M             # at 0x80208000
  pad_image images/zimage $SZ_8M          # at 0x80408000
  pad_image images/initramfs $SZ_20M      # at 0x80c08000

  if ! cat images/{u-boot.bin,MLO,u-boot.img,boot.scr,dtb,zimage,initramfs} > images/install-image; then
    error_exit "ERROR: failed to create install image"
  fi

  if ! cat images/{u-boot.bin,MLO,u-boot.img,erase.scr} > images/erase-image; then
    error_exit "ERROR: failed to create erase image"
  fi

  if ! cat images/{u-boot.bin,MLO,u-boot.img,kernel.scr,dtb,zimage,initramfs} > images/kernel-image; then
    error_exit "ERROR: failed to create kernel boot image"
  fi

  return 0
}

wait_for_emmc() {
  emmc=$1
  timeout=45
  echo "Waiting for mass storage device $emmc"
  while [ ! -b $emmc ]; do
    ((timeout--))
    if [ "$timeout" -lt "1" ]; then
      error_exit "ERROR: Timed out waiting for $emmc"
    fi
    sleep 1
  done

  echo "Found mass storage at $emmc"

  return 0
}

#
# Runs a shell script over the UART using socat.
# Will fail by default and only shows the following lines
# printed by the shell script:
# ERROR: Some message
# SUCCESS: Some message
# Returns 0 only if the shell script prints out a line
# SUCCESS: Some message
# Sorry, no passing of arguments to the script at this point.
#
serial_run_shell_script() {
  uart=$1
  test_script=$2
  verbose=$3
  ret=1

  if [ ! -f $test_script ]; then
    error_exit "Could not find script $test_script"
  fi

  while read -r output; do
    if [ "$verbose" == "1" ]; then
      echo $output
    fi
    if echo $output | grep "ERROR: " > /dev/null; then
      echo $output
      return 1
    fi
    if echo $output | grep "SUCCESS: " > /dev/null; then
      echo $output
      ret=0
    fi
  done < <(cat $test_script | sudo socat - $uart,ispeed=115200,ospeed=9600,raw,echo=0 2>&1)

  return $ret
}

install_on_emmc() {
  dieid=$1
  emmc=$2
  rootfs=$3

  echo "Partitioning $emmc..."
  if ! sudo /sbin/parted --script $emmc mklabel msdos; then
    error_exit "ERROR: Could not mklabel"
  fi
  if ! sudo /sbin/parted --script $emmc mkpart primary fat32 2048s 128MB; then
    error_exit "ERROR: Could not add fat32 partition"
  fi
  if ! sudo /sbin/parted --script $emmc mkpart primary ext4 128MB 100%; then
    error_exit "ERROR: Could not add ext4 partition"
  fi

  sleep 2 # let automount finish
  test -b $emmc-part1 && sudo umount $emmc-part1
  test -b $emmc-part2 && sudo umount $emmc-part2

  echo "Formatting new partitions on $emmc..."
  if ! sudo mkfs.vfat $(readlink -f $emmc-part1); then
    error_exit "ERROR: Could not mkfs.vfat"
  fi
  if ! sudo mkfs.ext4 $(readlink -f $emmc-part2); then
    error_exit "ERROR: Could not mkfs.ext4"
  fi

  echo "Adding tmp directories for mounting vfat and ext4..."
  if ! vfat=$(mktemp -d /tmp/$dieid-vfat-XXXXXXXX); then
    error_exit "ERROR: Could not mktemp for vfat"
  fi
  if ! ext4=$(mktemp -d /tmp/$dieid-ext4-XXXXXXXX); then
    error_exit "ERROR: Could not mktemp for ext4"
  fi
  if ! sudo mount $emmc-part1 $vfat; then
    error_exit "ERROR: Could not mount vfat"
  fi
  echo "Mounted vfat to temporary location $vfat"
  if ! sudo mount $emmc-part2 $ext4; then
    error_exit "ERROR: Could not mount ext4"
  fi
  echo "Mounted ext4 to temporary location $ext4"

  #
  # REVISIT: Add copying of MLO and u-boot to $vfat here
  #

  echo "Untarring root file system to $ext4..."
  if ! sudo tar zxf $rootfs -C $ext4; then
    error_exit "ERROR: Untarring failed for $rootfs"
  fi

  echo "Syncing, unmounting and cleaning up tmp directories..."
  sync
  if ! sudo umount $ext4; then
    error_exit "ERROR: Could not umount ext4"
  fi
  if ! sudo umount $vfat; then
    error_exit "ERROR: Could not umount vfat"
  fi
  test -d $ext4 && rmdir $ext4 # umount may unlink /tmp mountpoint
  test -d $vfat && rmdir $vfat
  return 0
}

#
# Invoke main function above
#
# sudo here and remove other sudo's?

main $@

